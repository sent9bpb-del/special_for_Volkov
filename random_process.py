import numpy as np                      # библиотека для численных вычислений (массивы, сортировка, std и т.д.)
import matplotlib.pyplot as plt         # библиотека для построения графиков
import math                             # стандартная математика (exp, sqrt, pow)

# -----------------------------
# ПАРАМЕТРЫ ГЕНЕРАТОРА (ЛКГ)
# -----------------------------
lambda1 = math.pow(5, 9)                # множитель линейного конгруэнтного генератора (ЛКГ)
lambda2 = math.pow(3, 8)                # модуль ЛКГ

# -----------------------------
# ТРЕБУЕМЫЕ ХАРАКТЕРИСТИКИ ПРОЦЕССА z(k)
# -----------------------------
M0 = 0.28                               # заданное (целевое) математическое ожидание процесса z(k)
sigma0_2 = 26 * 10**(-4)                # заданная (целевая) дисперсия процесса z(k)
alpha0 = 0.09                           # заданный параметр корреляции (в экспоненциальной аппроксимации)

# -----------------------------
# НАСТРОЙКИ ДЛЯ РАСЧЁТОВ
# -----------------------------
N = 210                                 # длина генерируемой последовательности x(k)
Kz_num = 20                             # сколько значений корреляционной функции Kz(S) считаем (S = 0..Kz_num-1)
Z0 = 1                                  # начальное значение для генератора ЛКГ

A1 = 1                                  # начальное значение параметра A1 для формирования z(k)
A2 = 1                                  # начальное значение параметра A2 для формирования z(k)
Ns = 10                                 # длина "окна" (число членов суммы) при формировании z(k)


# =========================================================
# 1) ГЕНЕРАЦИЯ ПСЕВДОСЛУЧАЙНОЙ ПОСЛЕДОВАТЕЛЬНОСТИ x(k)
# =========================================================
def generation_congurent_method(n, lam1, lam2, x0):
    """
    Линейный конгруэнтный метод:
        x[i] = (lam1 * x[i-1]) mod lam2

    Далее делаем нормировку:
        x_norm = x/lam2 - 0.5
    чтобы получить значения примерно в диапазоне [-0.5, 0.5].
    """
    x = [x0]                            # список исходных значений (начинаем с x0)
    for i in range(1, n):               # генерируем n-1 новых значений
        x.append((lam1 * x[i - 1]) % lam2)  # формула ЛКГ: умножение + модуль

    x_norm = [xi / lam2 - 0.5 for xi in x]  # нормировка в "центрированный" диапазон
    return x_norm                       # возвращаем нормированную последовательность


# =========================================================
# 2) ОЦЕНКА МАТ. ОЖИДАНИЯ
# =========================================================
def checkmate_waiting(z):
    """
    Оценка математического ожидания (среднего):
        M = (1/N) * Σ z[i]
    """
    return sum(z) / len(z)


# =========================================================
# 3) ОЦЕНКА ДИСПЕРСИИ
# =========================================================
def dispersion(z, M):
    """
    Оценка дисперсии:
        σ² = (1/N) * Σ (z[i] - M)^2
    """
    return sum((i - M) ** 2 for i in z) / len(z)


# =========================================================
# 4) КОРРЕЛЯЦИОННАЯ ФУНКЦИЯ
# =========================================================
def correlation_function(z, M, Smax):
    """
    Вычисление корреляционной функции K(S) для лагов S = 0..Smax-1:
        K(S) = (1/(N-S)) * Σ_{i=0..N-S-1} (z[i]-M)(z[i+S]-M)

    z    - процесс
    M    - мат ожидание
    Smax - максимум лага (сколько лагов считаем)
    """
    N_local = len(z)                    # длина процесса (локальная переменная, чтобы не путать с глобальной N)
    K = []                              # сюда будем складывать K(S)

    for S in range(Smax):               # перебираем лаги S
        ssum = 0                        # накопитель суммы для текущего лага
        for i in range(N_local - S):    # чтобы i+S не вышло за границы
            ssum += (z[i] - M) * (z[i + S] - M)  # вклад в корреляцию
        K.append(ssum / (N_local - S))  # нормируем на (N-S)

    return K


# =========================================================
# 5) АППРОКСИМАЦИЯ КОРРЕЛЯЦИИ ЭКСПОНЕНТОЙ И ПОИСК alpha
# =========================================================
def approximate_alpha(S, K, sig_2, max_iter=1000):
    """
    Хотим аппроксимировать корреляционную функцию экспонентой:
        K_appr(S) = σ² * exp(-α|S|)

    Здесь подбирается α (альфа) так, чтобы экспонента была "не меньше"
    по модулю, чем наблюдаемая корреляция |K(S)| (в твоей логике).

    Возвращает:
        alpha_final - итоговое α (среднее по всем лагам)
        k_appr      - массив аппроксимации для всех S
    """
    alph = []                           # список оценок alpha по каждому лагу

    for i in range(len(S)):             # идём по лагам
        alp = 1                         # стартовое значение альфа
        kt = sig_2 * math.exp(-alp * abs(S[i]))  # значение аппроксимации на текущем лаге
        it = 0                          # счётчик итераций

        # пока экспонента меньше |K|, уменьшаем alp (то есть делаем exp(-alp*S) "больше")
        while kt < abs(K[i]) and it < max_iter:
            alp -= 0.1                  # уменьшаем альфа шагом 0.1
            kt = sig_2 * math.exp(-alp * abs(S[i]))  # пересчитываем экспоненту
            it += 1

        # защита от слишком маленьких/нулевых значений
        alph.append(max(alp, 0.001))

    alpha_final = sum(alph) / len(alph) # усредняем alpha по всем лагам
    k_appr = [sig_2 * math.exp(-alpha_final * abs(S[i])) for i in range(len(S))]  # строим аппроксимацию
    return alpha_final, k_appr


# =========================================================
# 6) ФОРМИРОВАНИЕ СЛУЧАЙНОГО ПРОЦЕССА z(k) ПО x(k)
# =========================================================
def generate_process_z(x, A1, A2, sigma0_2, sigma_x0_2, alpha0, M0, Ns):
    """
    Формирование процесса z(k) через "сглаживание" последовательности x(k):
    z[k] = (1/Ns) * Σ_{i=k..k+Ns-1} x[i] * coeff * exp(-A2*alpha0*|i-k|) + M0

    Где coeff = sqrt( sigma0_2 / (sigma_x0_2 * alpha0 * A2) ) * A1

    x         - входная последовательность (случайная)
    A1, A2    - настраиваемые параметры модели
    sigma0_2  - целевая дисперсия z
    sigma_x0_2- дисперсия x
    alpha0    - целевое alpha
    M0        - целевое мат ожидание
    Ns        - размер окна суммирования
    """
    z = []                               # сюда будем записывать z(k)

    # k пробегает до len(x)-Ns, потому что нам нужен блок x[k..k+Ns-1]
    for k in range(len(x) - Ns):
        ssum = 0                         # сумма по окну

        for i in range(k, k + Ns):       # бежим по окну длиной Ns
            # множитель перед экспонентой (зависит от дисперсий и параметров модели)
            coeff = math.sqrt(sigma0_2 / (sigma_x0_2 * alpha0 * A2)) * A1

            # экспоненциальный вес (затухание по |i-k|)
            weight = math.exp(-A2 * alpha0 * abs(i - k))

            # вклад текущего элемента x[i] в сумму
            ssum += x[i] * coeff * weight

        # усредняем сумму по Ns и добавляем смещение M0
        z.append(ssum / Ns + M0)

    return z


# =========================================================
# 7) "СИМПЛЕКС-ПОИСК" ПАРАМЕТРОВ A1, A2 (упрощённый)
# =========================================================
def simplex_search(x, sigma_x2, M0, sigma0_2, alpha0, Ns,
                   A1_init=1.0, A2_init=1.0,
                   tol=0.1, max_iter=200):
    """
    Подбор A1 и A2 так, чтобы характеристики z(k) были ближе к (M0, sigma0_2, alpha0).

    Внутри считается ошибка:
        err = |(Mz-M0)/M0| + |(σz²-σ0²)/σ0²| + |(αz-α0)/α0|

    ВАЖНО: это упрощённая версия "симплекс-поиска":
    тут есть отражение, но нет расширения/сжатия/редукции как в полном Нелдер–Миде.
    """

    def process_error(A1, A2):
        """
        Функция ошибки для данных A1, A2.
        Чем меньше — тем лучше.
        """
        if A1 <= 0 or A2 <= 0:           # физически/математически некорректные параметры
            return 1e6                   # возвращаем огромную ошибку (штраф)

        z_local = generate_process_z(x, A1, A2, sigma0_2, sigma_x2, alpha0, M0, Ns)  # строим z(k)
        Mz_local = checkmate_waiting(z_local)                                        # среднее z
        sigma_z2_local = dispersion(z_local, Mz_local)                               # дисперсия z
        Kz_local = correlation_function(z_local, Mz_local, Kz_num)                   # корреляция z

        alpha_z_local, _ = approximate_alpha(range(Kz_num), Kz_local, sigma_z2_local)  # оценка alpha

        # суммарная относительная ошибка по трём характеристикам
        return (
            abs((Mz_local - M0) / M0)
            + abs((sigma_z2_local - sigma0_2) / sigma0_2)
            + abs((alpha_z_local - alpha0) / alpha0)
        )

    # задаём 3 точки симплекса (треугольник) в пространстве (A1, A2)
    simplex = [
        np.array([A1_init, A2_init]),            # базовая точка
        np.array([A1_init + 0.2, A2_init]),      # смещение по A1
        np.array([A1_init, A2_init + 0.2])       # смещение по A2
    ]

    # значения ошибки в вершинах симплекса
    values = [process_error(p[0], p[1]) for p in simplex]

    for _ in range(max_iter):
        # сортируем вершины по значению ошибки (по возрастанию)
        order = np.argsort(values)
        simplex = [simplex[i] for i in order]
        values = [values[i] for i in order]

        # best - лучшая вершина (минимальная ошибка)
        # worst - худшая вершина (максимальная ошибка)
        # second_worst - предпоследняя
        best, worst, second_worst = simplex[0], simplex[-1], simplex[-2]

        # центроид берём по двум лучшим вершинам (best и second_worst)
        centroid = (best + second_worst) / 2

        # отражение худшей точки относительно центроида
        reflected = centroid + (centroid - worst)

        # считаем ошибку в отражённой точке
        fr = process_error(reflected[0], reflected[1])

        # если отражение улучшает худшую точку, заменяем худшую вершину
        if fr < values[-1]:
            simplex[-1], values[-1] = reflected, fr

        # критерий остановки: если значения ошибок в симплексе почти не отличаются
        if np.std(values) < tol:
            break

    # возвращаем лучшую найденную пару (A1, A2)
    return simplex[0][0], simplex[0][1]


# =========================================================
# 8) ОСНОВНОЙ БЛОК: ГЕНЕРАЦИЯ И АНАЛИЗ
# =========================================================

# генерируем x(k) конгруэнтным методом
x = generation_congurent_method(N, lambda1, lambda2, Z0)

# оцениваем характеристики x
Mx = checkmate_waiting(x)               # среднее x
sigma_x2 = dispersion(x, Mx)            # дисперсия x

# если среднее не близко к 0, центрируем последовательность (делаем Mx ~ 0)
if abs(Mx) > 1e-6:
    x = [xi - Mx for xi in x]           # вычитаем среднее из каждого элемента
    Mx = checkmate_waiting(x)           # пересчитываем среднее
    sigma_x2 = dispersion(x, Mx)        # пересчитываем дисперсию

# формируем процесс z(k) при текущих A1, A2
z = generate_process_z(x, A1, A2, sigma0_2, sigma_x2, alpha0, M0, Ns)

# оцениваем характеристики z
Mz = checkmate_waiting(z)               # среднее z
sigma_z2 = dispersion(z, Mz)            # дисперсия z
Kz = correlation_function(z, Mz, Kz_num)  # корреляция z
alpha_z, K_apr = approximate_alpha(range(Kz_num), Kz, sigma_z2)  # оценка alpha и аппроксимация

# проверяем, укладываемся ли в 10% по всем трём характеристикам
# (Mz ~ M0), (sigma_z2 ~ sigma0_2), (alpha_z ~ alpha0)
within_10_percent = (
    abs((Mz - M0) / M0) <= 0.1
    and abs((sigma_z2 - sigma0_2) / sigma0_2) <= 0.1
    and abs((alpha_z - alpha0) / alpha0) <= 0.1
)

# если не укладываемся — запускаем подбор A1, A2
if not within_10_percent:
    A1, A2 = simplex_search(x, sigma_x2, M0, sigma0_2, alpha0, Ns)

    # после оптимизации нужно заново пересчитать z и характеристики
    z = generate_process_z(x, A1, A2, sigma0_2, sigma_x2, alpha0, M0, Ns)
    Mz = checkmate_waiting(z)
    sigma_z2 = dispersion(z, Mz)
    Kz = correlation_function(z, Mz, Kz_num)
    alpha_z, K_apr = approximate_alpha(range(Kz_num), Kz, sigma_z2)


# =========================================================
# 9) ВИЗУАЛИЗАЦИЯ (3 графика)
# =========================================================
plt.figure(figsize=(9, 8))              # создаём окно с заданным размером

plt.subplot(3, 1, 1)                    # 1-й график из 3 (вертикально)
plt.plot(x)                             # график x(k)

plt.subplot(3, 1, 2)                    # 2-й график
plt.plot(z)                             # график z(k)

plt.subplot(3, 1, 3)                    # 3-й график
plt.plot(range(Kz_num), Kz)             # экспериментальная Kz(S)
plt.plot(range(Kz_num), K_apr)          # аппроксимация σz²·exp(-αS)

plt.show()                              # показываем все графики
